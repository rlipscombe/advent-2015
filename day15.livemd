# Advent of Code 2015, Day 15

## Dependencies

```elixir
Mix.install([{:kino, github: "livebook-dev/kino"}])
```

## Puzzle Input

```elixir
input = Kino.Input.textarea("Puzzle Input:")
```

```elixir
re =
  ~r/(.*): capacity ([0-9-]+), durability ([0-9-]+), flavor ([0-9-]+), texture ([0-9-]+), calories ([0-9-]+)/

ingredients =
  Kino.Input.read(input)
  |> String.split("\n", trim: true)
  |> Enum.map(&Regex.run(re, &1, capture: :all_but_first))
  |> Enum.map(fn [ingredient, capacity, durability, flavor, texture, calories] ->
    {ingredient,
     %{
       capacity: String.to_integer(capacity),
       durability: String.to_integer(durability),
       flavor: String.to_integer(flavor),
       texture: String.to_integer(texture),
       calories: String.to_integer(calories)
     }}
  end)
  |> Enum.into(%{})
```

```elixir
ingredient_names = Enum.map(ingredients, fn {name, _properties} -> name end)
```

```elixir
defmodule Combinations do
  def get(ingredients, total), do: getp([], ingredients, total, [])

  # def getp([last], total, acc), do: [{last, total} | acc]

  defp getp(recipe, [ingredient], total, recipes) do
    [[{ingredient, total} | recipe] | recipes]
  end

  defp getp(recipe, [ingredient | ingredients], total, recipes) do
    Enum.reduce(0..total, recipes, fn i, recipes ->
      getp([{ingredient, i} | recipe], ingredients, total - i, recipes)
    end)
  end
end

1 = Combinations.get([:a], 2) |> Enum.count()
4 = Combinations.get([:a, :b], 3) |> Enum.count()
21 = Combinations.get([:a, :b, :c], 5) |> Enum.count()
286 = Combinations.get([:a, :b, :c, :d], 10) |> Enum.count()
:pass
```

```elixir
combinations = Combinations.get(ingredient_names, 100)
```

```elixir
Enum.count(combinations)
```

```elixir
score_recipe = fn recipe ->
  score =
    Enum.reduce(
      recipe,
      %{capacity: 0, durability: 0, flavor: 0, texture: 0, calories: 0},
      fn {ingredient_name, qty}, acc ->
        properties = Map.fetch!(ingredients, ingredient_name)

        %{
          acc
          | capacity: acc.capacity + qty * properties.capacity,
            durability: acc.durability + qty * properties.durability,
            flavor: acc.flavor + qty * properties.flavor,
            texture: acc.texture + qty * properties.texture,
            calories: acc.calories + qty * properties.calories
        }
      end
    )

  score = %{
    capacity: if(score.capacity > 0, do: score.capacity, else: 0),
    durability: if(score.durability > 0, do: score.durability, else: 0),
    flavor: if(score.flavor > 0, do: score.flavor, else: 0),
    texture: if(score.texture > 0, do: score.texture, else: 0),
    calories: if(score.calories > 0, do: score.calories, else: 0)
  }

  score
end
```

```elixir
:timer.tc(fn ->
  score_recipe.([
    {"Butterscotch", 44},
    {"Cinnamon", 56}
  ])
end)
```

```elixir
:timer.tc(fn ->
  score_recipe.([
    {"Sugar", 0},
    {"Frosting", 0},
    {"PeanutButter", 0},
    {"Sprinkles", 100}
  ])
end)
```

```elixir
# 59.3s !!
cookies =
  combinations
  |> Enum.map(fn recipe ->
    {recipe, score_recipe.(recipe)}
  end)
```

```elixir
cookies
|> Enum.map(fn {_recipe, score} ->
  Enum.reduce(score, 1, fn
    {:calories, _}, acc -> acc
    {_, a}, acc -> acc * a
  end)
end)
|> Enum.max()
```

## Part 2

```elixir
healthy_cookies =
  cookies
  |> Enum.filter(fn {recipe, score} ->
    score.calories == 500
  end)
```

```elixir
healthy_cookies
|> Enum.map(fn {_recipe, score} ->
  Enum.reduce(score, 1, fn
    {:calories, _}, acc -> acc
    {_, a}, acc -> acc * a
  end)
end)
|> Enum.max()
```
